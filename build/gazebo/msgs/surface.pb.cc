// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: surface.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "surface.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
#pragma GCC diagnostic ignored "-Wshadow"
// @@protoc_insertion_point(includes)

namespace gazebo {
namespace msgs {

namespace {

const ::google::protobuf::Descriptor* Surface_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Surface_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_surface_2eproto() {
  protobuf_AddDesc_surface_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "surface.proto");
  GOOGLE_CHECK(file != NULL);
  Surface_descriptor_ = file->message_type(0);
  static const int Surface_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, friction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, restitution_coefficient_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, bounce_threshold_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, soft_cfm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, soft_erp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, kp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, kd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, max_vel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, min_depth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, collide_without_contact_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, collide_without_contact_bitmask_),
  };
  Surface_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Surface_descriptor_,
      Surface::default_instance_,
      Surface_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Surface, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Surface));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_surface_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Surface_descriptor_, &Surface::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_surface_2eproto() {
  delete Surface::default_instance_;
  delete Surface_reflection_;
}

void protobuf_AddDesc_surface_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::gazebo::msgs::protobuf_AddDesc_friction_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\rsurface.proto\022\013gazebo.msgs\032\016friction.p"
    "roto\"\227\002\n\007Surface\022\'\n\010friction\030\001 \001(\0132\025.gaz"
    "ebo.msgs.Friction\022\037\n\027restitution_coeffic"
    "ient\030\002 \001(\001\022\030\n\020bounce_threshold\030\003 \001(\001\022\020\n\010"
    "soft_cfm\030\004 \001(\001\022\020\n\010soft_erp\030\005 \001(\001\022\n\n\002kp\030\006"
    " \001(\001\022\n\n\002kd\030\007 \001(\001\022\017\n\007max_vel\030\010 \001(\001\022\021\n\tmin"
    "_depth\030\t \001(\001\022\037\n\027collide_without_contact\030"
    "\n \001(\010\022\'\n\037collide_without_contact_bitmask"
    "\030\013 \001(\r", 326);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "surface.proto", &protobuf_RegisterTypes);
  Surface::default_instance_ = new Surface();
  Surface::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_surface_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_surface_2eproto {
  StaticDescriptorInitializer_surface_2eproto() {
    protobuf_AddDesc_surface_2eproto();
  }
} static_descriptor_initializer_surface_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int Surface::kFrictionFieldNumber;
const int Surface::kRestitutionCoefficientFieldNumber;
const int Surface::kBounceThresholdFieldNumber;
const int Surface::kSoftCfmFieldNumber;
const int Surface::kSoftErpFieldNumber;
const int Surface::kKpFieldNumber;
const int Surface::kKdFieldNumber;
const int Surface::kMaxVelFieldNumber;
const int Surface::kMinDepthFieldNumber;
const int Surface::kCollideWithoutContactFieldNumber;
const int Surface::kCollideWithoutContactBitmaskFieldNumber;
#endif  // !_MSC_VER

Surface::Surface()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Surface::InitAsDefaultInstance() {
  friction_ = const_cast< ::gazebo::msgs::Friction*>(&::gazebo::msgs::Friction::default_instance());
}

Surface::Surface(const Surface& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Surface::SharedCtor() {
  _cached_size_ = 0;
  friction_ = NULL;
  restitution_coefficient_ = 0;
  bounce_threshold_ = 0;
  soft_cfm_ = 0;
  soft_erp_ = 0;
  kp_ = 0;
  kd_ = 0;
  max_vel_ = 0;
  min_depth_ = 0;
  collide_without_contact_ = false;
  collide_without_contact_bitmask_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Surface::~Surface() {
  SharedDtor();
}

void Surface::SharedDtor() {
  if (this != default_instance_) {
    delete friction_;
  }
}

void Surface::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Surface::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Surface_descriptor_;
}

const Surface& Surface::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_surface_2eproto();
  return *default_instance_;
}

Surface* Surface::default_instance_ = NULL;

Surface* Surface::New() const {
  return new Surface;
}

void Surface::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_friction()) {
      if (friction_ != NULL) friction_->::gazebo::msgs::Friction::Clear();
    }
    restitution_coefficient_ = 0;
    bounce_threshold_ = 0;
    soft_cfm_ = 0;
    soft_erp_ = 0;
    kp_ = 0;
    kd_ = 0;
    max_vel_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    min_depth_ = 0;
    collide_without_contact_ = false;
    collide_without_contact_bitmask_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Surface::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .gazebo.msgs.Friction friction = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_friction()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_restitution_coefficient;
        break;
      }

      // optional double restitution_coefficient = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_restitution_coefficient:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &restitution_coefficient_)));
          set_has_restitution_coefficient();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_bounce_threshold;
        break;
      }

      // optional double bounce_threshold = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_bounce_threshold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &bounce_threshold_)));
          set_has_bounce_threshold();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(33)) goto parse_soft_cfm;
        break;
      }

      // optional double soft_cfm = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_soft_cfm:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &soft_cfm_)));
          set_has_soft_cfm();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(41)) goto parse_soft_erp;
        break;
      }

      // optional double soft_erp = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_soft_erp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &soft_erp_)));
          set_has_soft_erp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(49)) goto parse_kp;
        break;
      }

      // optional double kp = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_kp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &kp_)));
          set_has_kp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(57)) goto parse_kd;
        break;
      }

      // optional double kd = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_kd:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &kd_)));
          set_has_kd();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(65)) goto parse_max_vel;
        break;
      }

      // optional double max_vel = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_max_vel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_vel_)));
          set_has_max_vel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(73)) goto parse_min_depth;
        break;
      }

      // optional double min_depth = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_min_depth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &min_depth_)));
          set_has_min_depth();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_collide_without_contact;
        break;
      }

      // optional bool collide_without_contact = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_collide_without_contact:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &collide_without_contact_)));
          set_has_collide_without_contact();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_collide_without_contact_bitmask;
        break;
      }

      // optional uint32 collide_without_contact_bitmask = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_collide_without_contact_bitmask:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &collide_without_contact_bitmask_)));
          set_has_collide_without_contact_bitmask();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Surface::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .gazebo.msgs.Friction friction = 1;
  if (has_friction()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->friction(), output);
  }

  // optional double restitution_coefficient = 2;
  if (has_restitution_coefficient()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->restitution_coefficient(), output);
  }

  // optional double bounce_threshold = 3;
  if (has_bounce_threshold()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->bounce_threshold(), output);
  }

  // optional double soft_cfm = 4;
  if (has_soft_cfm()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->soft_cfm(), output);
  }

  // optional double soft_erp = 5;
  if (has_soft_erp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->soft_erp(), output);
  }

  // optional double kp = 6;
  if (has_kp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->kp(), output);
  }

  // optional double kd = 7;
  if (has_kd()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->kd(), output);
  }

  // optional double max_vel = 8;
  if (has_max_vel()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(8, this->max_vel(), output);
  }

  // optional double min_depth = 9;
  if (has_min_depth()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->min_depth(), output);
  }

  // optional bool collide_without_contact = 10;
  if (has_collide_without_contact()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->collide_without_contact(), output);
  }

  // optional uint32 collide_without_contact_bitmask = 11;
  if (has_collide_without_contact_bitmask()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->collide_without_contact_bitmask(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Surface::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .gazebo.msgs.Friction friction = 1;
  if (has_friction()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->friction(), target);
  }

  // optional double restitution_coefficient = 2;
  if (has_restitution_coefficient()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->restitution_coefficient(), target);
  }

  // optional double bounce_threshold = 3;
  if (has_bounce_threshold()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->bounce_threshold(), target);
  }

  // optional double soft_cfm = 4;
  if (has_soft_cfm()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->soft_cfm(), target);
  }

  // optional double soft_erp = 5;
  if (has_soft_erp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->soft_erp(), target);
  }

  // optional double kp = 6;
  if (has_kp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->kp(), target);
  }

  // optional double kd = 7;
  if (has_kd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->kd(), target);
  }

  // optional double max_vel = 8;
  if (has_max_vel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(8, this->max_vel(), target);
  }

  // optional double min_depth = 9;
  if (has_min_depth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(9, this->min_depth(), target);
  }

  // optional bool collide_without_contact = 10;
  if (has_collide_without_contact()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(10, this->collide_without_contact(), target);
  }

  // optional uint32 collide_without_contact_bitmask = 11;
  if (has_collide_without_contact_bitmask()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->collide_without_contact_bitmask(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Surface::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .gazebo.msgs.Friction friction = 1;
    if (has_friction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->friction());
    }

    // optional double restitution_coefficient = 2;
    if (has_restitution_coefficient()) {
      total_size += 1 + 8;
    }

    // optional double bounce_threshold = 3;
    if (has_bounce_threshold()) {
      total_size += 1 + 8;
    }

    // optional double soft_cfm = 4;
    if (has_soft_cfm()) {
      total_size += 1 + 8;
    }

    // optional double soft_erp = 5;
    if (has_soft_erp()) {
      total_size += 1 + 8;
    }

    // optional double kp = 6;
    if (has_kp()) {
      total_size += 1 + 8;
    }

    // optional double kd = 7;
    if (has_kd()) {
      total_size += 1 + 8;
    }

    // optional double max_vel = 8;
    if (has_max_vel()) {
      total_size += 1 + 8;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional double min_depth = 9;
    if (has_min_depth()) {
      total_size += 1 + 8;
    }

    // optional bool collide_without_contact = 10;
    if (has_collide_without_contact()) {
      total_size += 1 + 1;
    }

    // optional uint32 collide_without_contact_bitmask = 11;
    if (has_collide_without_contact_bitmask()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->collide_without_contact_bitmask());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Surface::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Surface* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Surface*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Surface::MergeFrom(const Surface& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_friction()) {
      mutable_friction()->::gazebo::msgs::Friction::MergeFrom(from.friction());
    }
    if (from.has_restitution_coefficient()) {
      set_restitution_coefficient(from.restitution_coefficient());
    }
    if (from.has_bounce_threshold()) {
      set_bounce_threshold(from.bounce_threshold());
    }
    if (from.has_soft_cfm()) {
      set_soft_cfm(from.soft_cfm());
    }
    if (from.has_soft_erp()) {
      set_soft_erp(from.soft_erp());
    }
    if (from.has_kp()) {
      set_kp(from.kp());
    }
    if (from.has_kd()) {
      set_kd(from.kd());
    }
    if (from.has_max_vel()) {
      set_max_vel(from.max_vel());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_min_depth()) {
      set_min_depth(from.min_depth());
    }
    if (from.has_collide_without_contact()) {
      set_collide_without_contact(from.collide_without_contact());
    }
    if (from.has_collide_without_contact_bitmask()) {
      set_collide_without_contact_bitmask(from.collide_without_contact_bitmask());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Surface::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Surface::CopyFrom(const Surface& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Surface::IsInitialized() const {

  if (has_friction()) {
    if (!this->friction().IsInitialized()) return false;
  }
  return true;
}

void Surface::Swap(Surface* other) {
  if (other != this) {
    std::swap(friction_, other->friction_);
    std::swap(restitution_coefficient_, other->restitution_coefficient_);
    std::swap(bounce_threshold_, other->bounce_threshold_);
    std::swap(soft_cfm_, other->soft_cfm_);
    std::swap(soft_erp_, other->soft_erp_);
    std::swap(kp_, other->kp_);
    std::swap(kd_, other->kd_);
    std::swap(max_vel_, other->max_vel_);
    std::swap(min_depth_, other->min_depth_);
    std::swap(collide_without_contact_, other->collide_without_contact_);
    std::swap(collide_without_contact_bitmask_, other->collide_without_contact_bitmask_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Surface::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Surface_descriptor_;
  metadata.reflection = Surface_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace msgs
}  // namespace gazebo

GZ_REGISTER_STATIC_MSG("gazebo.msgs.Surface", Surface)
// @@protoc_insertion_point(global_scope)
